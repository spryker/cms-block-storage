<section class="spy-layout plain text-columns">
<h3>Using angularjs inside the Spryker Backend</h3>

<p>
    Every Component of the Spryker UI is designed to be completely replaceable and not obstructive of the use of alternative technologies.
    A blank new page will contain no active components.
    To enable the active Ui Components in the Spryker UI you will have to define one or multiple angularjs applications.
</p>

<pre><code class="html">&lt;any spy-app=&quot;moduleOne,moduleTwo,&hellip;&quot; ng-strict-di&gt;&hellip;&lt;/any&gt;</code></pre>

<p>
    The <code>spy-app</code> directive does the same thing as the angularjs native <code>ng-app</code> directive, while lifting two of its restrictions.
    First when using <code>spy-app</code> exclusively, you will be able to create multiple angular applications on the same page.
    And second you are allowed to specify multiple comma separated module names to be loaded with your angular application.
</p>

<h4>Communication between components</h4>

<p>
    The communication between disconnected components is based on the event system built into angularjs,
    but it adds capabilities to direct events to interested parties,
    to define event listeners in declarative fashion directly inside the html
    and to run your listener code not just inside the local scope, but anywhere inside the angularjs application.
</p>

<p>
    The base <code>angularjs</code> component supplies the basic facilities for emitting and listening to events inside spryker angularjs applications.
    To enable the base component, load the module <code>spyBase</code> inside your <code>spy-app</code> declaration.
    Since the <code>spyBase</code> module is the base of all other modules, you will very seldom have the need to declare <code>spyBase</code> directly.
</p>

<h5>Listening to events</h5>

<p>
    Use the <code>spy-listen</code> directive to listen to the events you are triggering inside your application.
    Additionally to <code>spy-listen</code>, each component of the application will provide it's own event listening directives for the events they are emitting.
    Whenever you want to listen to the events of an internal component, it is advised to use its own listener directives instead of <code>spy-listen</code>.
    Whenever you name and trigger an event yourself, you should use <code>spy-listen</code> to listen to and act on it.
</p>

<p>
    When using <code>spy-listen</code> and related directives, all events will be listened to using the <code>$rootScope</code> of the angularjs application.
    This way you will not have to concern yourself with the internals of the angularjs event system.
</p>

<pre><code class="html">&lt;spy-listen
    on=&quot;&lt;event name&gt;&quot;
    do=&quot;&lt;expression&gt;&quot;
    scope=&quot;&lt;named scope&gt;&quot;
    channel=&quot;&lt;event-channel-1,event-channel-2,&hellip;&gt;&quot;
&gt;&lt;/spy-listen&gt;</code></pre>

<dl>
    <dt>on</dt>
    <dd>The event name may be any string</dd>

    <dt>do</dt>
    <dd>An angularjs expression</dd>
    <dd>Use <code>$argument</code> inside the expression to get access to the context object supplied by the event emitter.</dd>

    <dt>scope</dt>
    <dd>The name of the view-unique named scope inside which to run <code>expression</code>.</dd>
    <dd>The <code>scope</code> attribute is optional. If missing, <code>expression</code> will run inside the local scope.</dd>

    <dt>channel</dt>
    <dd>Comma separated list of event channels.</dd>
    <dd>The <code>channel</code> attribute is optional. If missing, the listener will only react to events on the unnamed global channel.</dd>
</dl>

<h5>Emitting events</h5>

<p>
    Creating basic events works exactly the way it would in vanilla angulars by using <code>$emit()</code>.
    The Spryker Ui does not interfere with the basic functioning of <code>$emit()</code>.
    <code>spy-listen</code> assumes the second argument of <code>$emit()</code> to be the context object and the third the event channel.
    If no event channel is supplied the global channel is implicit.
</p>

<pre><code class="javascript">$emit(name, context, channel);</code></pre>

<dl>
    <dt>name</dt>
    <dd>A string representing the event name</dd>

    <dt>context</dt>
    <dd>The optional event context object. Will be accessible through <code>$argument</code> inside listeners.</dd>

    <dt>channel</dt>
    <dd>A string representing the optional event channel. If no event channel is supplied, the global channels is assumed</dd>
</dl>

<p>If you plan to emit to <code>spy-listen</code>, you can also use <code>$emitChannel</code> to make your intent explicit.</p>

<pre><code class="javascript">$emitChannel(name, channel, context);</code></pre>

<p>
    If you are using a named scope and have its channels registered inside its <code>channel</code> attribute,
    you can use <code>$emitAllChannels()</code> to emit events through all registered channels.
</p>

<pre><code class="javascript">$emitAllChannels(name, context)</code></pre>

<dl>
    <dt>name</dt>
    <dd>A string representing the event name</dd>

    <dt>context</dt>
    <dd>The optional event context object. Will be accessible through <code>$argument</code> inside listeners.</dd>
</dl>

</section>